import matplotlib.pyplot as plt
import numpy as np
import cmath
import numpy.fft as fft
plt.rcParams['axes.grid'] = True

# Homework project - graded 98%

# PART 1 - In this part of the exercise we define a 'couple' function which models the behaviour of the coupler as
# described by equation 1. The coupler takes an Ein array and generates 2 E output arrays corresponding to each arm
# of the output. The function created here will also be used for the remainder of the exercise, as we can simply
# vary the array passed in as Ein for various input fields. Once the E outputs are generated by the matmul
# in the created function, the intensity is found by using the 'complexsq' function which finds the complex square of a
# given complex array or value. These are then plotted to show the relationship between the coupling ratio and
# intensity.


def couple(E, k):
    """
    E: takes input vector to be matrix multiplied by transformation matrix
    k: coupling parameter
    returns: resulting matrix with real and imaginary solutions in [0] and [1] respectively, then finds the modulus.
    This function ensures all E values are strictly real
    """
    mat1 = np.array([[(1 - k)**0.5, 1j * (k**0.5)], [1j * (k**0.5), (1 - k)**0.5]])
    return np.matmul(mat1, E)


def complexsq(x):
    """
    Finds the complex square by multiplying a complex array or value by it's complex conjugate
    """
    return x * np.conj(x)


k_array = np.linspace(0, 1, 101)  # coupling ratio linspace
Ein1 = np.array([[1 + 0j], [0 + 0j]])  # E input matrix for eq1

Eout1 = []
Eout2 = []
for i in range(len(k_array)):
    matmul = couple(Ein1, k_array[i])  # computes equation 1, generating outputs from the passed in Ein values
    Eout1 = np.array(np.append(Eout1, matmul[0]))  # appends the value of matmul[0] for given k, corresponds to Eout1
    Eout2 = np.array(np.append(Eout2, matmul[1]))  # Eout2 append

I11 = complexsq(Eout1)  # I = E**2 for E1out, using complex squaring function created
I21 = complexsq(Eout2)  # I = E**2 for E2out

# PART 2- In the first graph for k = 0.5, both fields have an equal share of the intensity as 1-k = 0.5 and so the graph
# is symmetrical. For k = 0.75 however, 1-k = 0.25, meaning there is a 3:1 ratio between the fields generated by each
# arm alternating between positive and negative, hence the term coupling "ratio".

# In this part of the exercise, we hold the coupling ratio at a given constant value and model equation 2 as a function
# of the phase difference of the 2 arms, and then repeat this for the other coupling ratio. This is modelled through
# the use of a nested for loop with the parent loop iterating through our k values and the inner loop iterating through
# the phase for a constant k. For each value of k, the Ein matrix is passed through the coupler as described by equation
# 1 before being passed through the fibre as described in equation 2. The data generated through the loop was appended
# to an empty list where it was then converted to an array and specific data for each arm was extracted through index
# slicing.

k = [0.5, 0.75]  # coupling ratio
phi2 = 0  # held constant to create a phase difference
phi1 = np.linspace(0, 4 * np.pi, 101)  # array containing the angle we will iterate through for our matmul

Eins = []
for j in range(len(k)):
    # Nested for loop to iterate through k values while also iterating through phi values
    for i in range(len(phi1)):
        matmul = couple(Ein1, k[j])  # creates new Eouts to be used in equation 2
        mat2 = np.array([matmul[0] * np.exp(phi1[i] * 1j), matmul[1] * np.exp(1j * phi2)])  # input matrix as in eq2
        result = couple(mat2, k[j])  # computes matrix multiplication using couple function for k at index j
        Eins.append(result)


intensity2 = complexsq(np.array(Eins))  # I = E**2, this holds a (202, 2) array of data where the first 101 are k[0]
I201 = intensity2[0:101, 0]  # I for K[0], E1
I202 = intensity2[0:101, 1]  # I for K[0], E2
I211 = intensity2[101:202, 0]  # I for K[1], E1
I212 = intensity2[101:202, 1]  # I for K[1], E2

# PART 3 - Here we are computing the intensity as a function of the coupling ratio k with no phase difference between
# the 2 input ports. As in previous steps, the intensity is calculated by taking the complex square of the E field
# generated from the matrix multiplication as described in equation 3.

phi1 = np.linspace(0, 4*np.pi, 101)  # phase linspace
phi2 = phi1  # these are equal since they are in phase

Ein3 = []
for i in range(len(k_array)):
    matmul = couple(Ein1, k_array[i])  # computes eq 1 for various k vals, resulting matmul[0], matmul[1] = Eout1, Eout2
    mat2 = np.array([matmul[0] * np.exp(phi1[i] * 1j), matmul[1] * np.exp(1j * phi2[i])])[::-1]  # input matrix for eq3
    result = couple(mat2, k_array[i])  # computes eq 3 for passed in k value
    Ein3.append(result)


intensity3 = complexsq(np.array(Ein3))  # finds the complex square of E
I31 = intensity3[:, 0]  # Intensity for E1
I32 = intensity3[:, 1]  # Intensity for E2

# PART 1 PLOT
fig, ((ax3, ax1), (ax2, ax4)) = plt.subplots(2, 2, figsize=(12, 8))
ax3.set(title='Intensity against coupling ratio k', xlabel='Coupling ratio, k', ylabel='Intensity (W/m2)')
ax3.plot(k_array, I11, label='Arm 1')
ax3.plot(k_array, I21, label='Arm 2')
ax3.legend(loc='best')
# PART 2 PLOT
ax1.set(title='Intensity against phase difference for k = 0.5', xlabel='Phase (*pi rads)', ylabel='Intensity (W/m2)')
ax1.plot(phi1, I201, label='Arm 1')
ax1.plot(phi1, I202, label='Arm 2')
plt.tight_layout()
ax1.legend(loc='best')

ax2.set(title='Intensity against phase difference for k = 0.75', xlabel='Phase (*pi rads)', ylabel='Intensity (W/m2)')
ax2.plot(phi1, I211, label='Arm 1')
ax2.plot(phi1, I212, label='Arm 2')
ax2.legend(loc='best')
# PART 3 PLOT
ax4.set(title='Intensity against coupling ratio k', xlabel='Coupling ratio, k', ylabel='Intensity (W/m2)')
ax4.plot(k_array, I31, label='Arm 1')
ax4.plot(k_array, I32, label='Arm 2')
ax4.legend(loc='best')
plt.tight_layout()
plt.show()

# PART 4 - in this part of the exercise, we are modelling the intensity as a function of the input field as described
# by equation 6. Our E inputs were created using a linspace, passed through the coupler to generate the corresponding
# E outputs and then passed in through the fibre as in equation 6.

k = 0.6
Ein4 = np.linspace(0, 10, 101)  # New E input linspace to vary intensity as a function of E
d = 0.5

Eout4 = []
for i in range(len(Ein4)):
    Einx = np.array([Ein4[i] + 0j, 0 + 0j])  # E inputs at given index
    matmul = couple(Einx, k)  # creating new E outputs, matmul[0] corresponds to E1 and matmul[1] = E2
    matrix5 = np.array([matmul[0] * (cmath.e ** (1j * d * complexsq(matmul[0]))),
                        matmul[1] * (cmath.e ** (1j * d * complexsq(matmul[1])))])  # new E input for equation 6
    matmul5 = couple(matrix5, k)  # computes equation 6
    Eout4.append(matmul5)


intensity4 = complexsq(np.array(Eout4))  # takes E outputs and finds the modulus squared since I = E**2, creates array
I41 = intensity4[:, 0]
I42 = intensity4[:, 1]

# PART 4 PLOTS
plt.figure()
plt.plot(Ein4, I41, '+', label='Arm 1')
plt.plot(Ein4, I42, 'o', label='Arm 2')
plt.title('Intensity against E field for k = 0.6')
plt.xlabel('\nElectric Field (Vm-1 rads)')
plt.ylabel('Intensity (W/m2)')
plt.legend(loc='best')
plt.show()

# PART 5 - here we extended part 4 and modelled a pulse described by equation 7 for our desired amplitude. Here we
# generate our input array using a time linspace with eq 7 then pass it through the coupler, then use the outputs to
# generate the temporal profile of the intensity of each input port using equation 6. This was done over a range of
# varying amplitudes, hence the use of a nested loop to iterate through A values while iterating through the varying
# input values. Once we had modelled the temporal profile of the pulse, we then used a fourier transform to generate
# data in the frequency domain. Intensities in the temporal domain were found by taking the complex square of the
# generated E field outputs but in order to compute the intensities in the frequency domain, the E field outputs were
# left in the complex form to preserve the data before passing it into the fourier transform. After the E field data
# had been transformed to the frequency domain, the intensities were finally calculated by taking the complex square of
# the data in this domain. Methods such as numpy.fft.fftfreq can be used to transform a given time array into a
# frequency array, giving us our frequency grid for the x-axis. The graphs titled input pulse correspond to the pulse
# before entering the fibre.

tp = 10e-12  # pulsewidth
grid_points = 2048  # Creating grid points with n = length of our array to be transformed
t, dt = np.linspace(-50. * tp, 50. * tp, grid_points, False, True)  # time linspace used for eq7

A = [3.0, 4.5, 6.9, 8.2]  # array holding amplitude values
Ein5 = A[1]/np.cosh(t/tp)  # eq 7 for a single value of A = 4.5, using our t linspace, corresponds to input pulse

Eout5b = []
for j in range(len(A)):
    #  Nested for loop to iterate through Amplitudes while iterating through Ein values
    for i in range(len(Ein5)):
        Ein = A[j] / np.cosh(t / tp)  # Creates E inputs for the given amplitude
        Einx = np.array([Ein[i] + 0j, 0 + 0j])  # Uses E value at given index as E input
        matmul = couple(Einx, k)  # matrix multiplication of Ein[i] for A[j] where matmul[0], matmul[1] = E1, E2
        matrix5b = np.array([matmul[0] * (cmath.e ** (1j * d * complexsq(matmul[0]))),
                             matmul[1] * (cmath.e ** (1j * d * complexsq(matmul[1])))])  # new input matrix for eq6
        matmul5b = couple(matrix5b, k)  # computes eq 6
        Eout5b.append(matmul5b)


E_array = np.array(Eout5b)  # Data stored in complex form for fourier analysis

E1A0 = E_array[0:2048, 0]  # E1 at A[0] = 3.0
E2A0 = E_array[0:2048, 1]  # E2
E1A1 = E_array[2048:(2048*2), 0]  # E1 at A[1] = 4.5
E2A1 = E_array[2048:(2048*2), 1]  # E2
E1A2 = E_array[(2048*2):(2048*3), 0]  # E1 at A[2] = 6.9
E2A2 = E_array[(2048*2):(2048*3), 1]  # E2
E1A3 = E_array[(2048*3):(2048*4), 0]  # E1 at A[3] = 8.2
E2A3 = E_array[(2048*3):(2048*4), 1]  # E2

# Intensities calculated for each arm and amplitude
I5A1 = complexsq(E1A0)  # A = 3.0
I5A2 = complexsq(E2A0)
I5B1 = complexsq(E1A1)  # A = 4.5
I5B2 = complexsq(E2A1)
I5C1 = complexsq(E1A2)  # A = 6.9
I5C2 = complexsq(E2A2)
I5D1 = complexsq(E1A3)  # A = 8.2
I5D2 = complexsq(E2A3)

# FOURIER TRANSFORMS
freq = fft.fftfreq(grid_points, dt)  # creating frequency array from time data to be used as frequency grid

infft = fft.fft(Ein5/2048)  # computes a fourier transform on the array, generates E field data in frequency domain

fftE15 = fft.fft(E1A1/2048)  # E field profile of A = 4.5
fftE25 = fft.fft(E2A1/2048)

fft1A = fft.fft(E1A0/2048)  # E field profile of A = 3.0
fft2A = fft.fft(E2A0/2048)

fft1B = fft.fft(E1A2/2048)  # E field profile of A = 6.9
fft2B = fft.fft(E2A2/2048)

fft1C = fft.fft(E1A3/2048)  # E field profile of A = 8.2
fft2C = fft.fft(E2A3/2048)

# PART 5 PLOTS
fig, ((ax0, ax2, ax1, ax3, ax4), (ax01, ax5, ax6, ax7, ax8)) = plt.subplots(2, 5, figsize=(18, 8))
ax0.set(title='Temporal profile for input pulse', xlabel='Time(ps)', ylabel='Intensity (W/m2)', xlim=(-70, 70))
ax0.plot(t*1e12, Ein5)

ax01.set(title='Spectral profile of input pulse', xlabel='Frequency (THz)', ylabel='Intensity (W/m2)', xlim=(-0.5, 0.5))
ax01.plot(freq*1e-12, complexsq(infft))

ax1.plot(t*1e12, I5B1, label='Arm 1')
ax1.plot(t*1e12, I5B2, label='Arm 2')
ax1.set(title='\nTemporal profile for A = 4.5', xlabel='\nTime(ps)', ylabel='Intensity (W/m2)', xlim=(-40, 40))
ax1.legend(loc='best')

ax2.plot(t*1e12, I5A1, label='Arm 1')
ax2.plot(t*1e12, I5A2, label='Arm 2')
ax2.set(title='\nTemporal profile for A = 3.0', xlabel='\nTime(ps)', ylabel='Intensity (W/m2)', xlim=(-40, 40))
ax2.legend(loc='best')

ax3.plot(t*1e12, I5C1, label='Arm 1')
ax3.plot(t*1e12, I5C2, label='Arm 2')
ax3.set(title='\nTemporal profile for A = 6.9', xlabel='\nTime(ps)', ylabel='Intensity (W/m2)', xlim=(-40, 40))
ax3.legend(loc='best')

ax4.plot(t*1e12, I5D1, label='Arm 1')
ax4.plot(t*1e12, I5D2, label='Arm 2')
ax4.set(title='\nTemporal profile for A = 8.2', xlabel='\nTime(ps)', ylabel='Intensity (W/m2)', xlim=(-40, 40))
ax4.legend(loc='best')

ax5.set(title='Spectral profile for A = 3.0', xlabel='\nFrequency (THz)', ylabel='Intensity (W/m2)', xlim=(-0.4, 0.4))
ax5.plot(freq*1e-12, complexsq(fft1A), label='Arm 1')
ax5.plot(freq*1e-12, complexsq(fft2A), label='Arm 2')
ax5.legend(loc='best')

ax6.set(title='\nSpectral profile for A = 4.5', xlabel='\nFrequency (THz)', ylabel='Intensity (W/m2)', xlim=(-0.4, 0.4))
ax6.plot(freq*1e-12, complexsq(fftE15), label='Arm 1')
ax6.plot(freq*1e-12, complexsq(fftE25), label='Arm 2')
ax6.legend(loc='best')

ax7.set(title='\nSpectral profile for A = 6.9', xlabel='\nFrequency (THz)', ylabel='Intensity (W/m2)', xlim=(-0.4, 0.4))
ax7.plot(freq*1e-12, complexsq(fft1B), label='Arm 1')
ax7.plot(freq*1e-12, complexsq(fft2B), label='Arm 2')
ax7.legend(loc='best')

ax8.set(title='\nSpectral profile for A = 8.2', xlabel='\nFrequency (THz)', ylabel='Intensity (W/m2)', xlim=(-0.4, 0.4))
ax8.plot(freq*1e-12, complexsq(fft1C), label='Arm 1')
ax8.plot(freq*1e-12, complexsq(fft2C), label='Arm 2')
ax8.legend(loc='best')
plt.tight_layout()
plt.show()
